// const OpenAI = require('openai');
// const Shoes = require('../models/shoes.model');
// const ShoesVariant = require('../models/shoes_variant.model'); // Th√™m d√≤ng n√†y
// require('dotenv').config();

// const openai = new OpenAI({
//   apiKey: process.env.OPENAI_API_KEY
// });

// exports.suggestProducts = async (req, res) => {
//   try {
//     const { message } = req.body;

//     // 1. L·∫•y danh s√°ch s·∫£n ph·∫©m t·ª´ database v·ªõi variants
//     const shoes = await Shoes.find({ status: { $ne: 'hidden' } }) // Ch·ªâ l·∫•y s·∫£n ph·∫©m kh√¥ng ·∫©n
//       .populate('brand_id')
//       .populate('category_id');

//     const shoesWithVariants = await Promise.all(shoes.map(async (shoe) => {
//       const variants = await ShoesVariant.find({ 
//         shoes_id: shoe._id,
//         status: 'available',  // Ch·ªâ l·∫•y variant c√≤n h√†ng
//         quantity_in_stock: { $gt: 0 } // S·ªë l∆∞·ª£ng c√≤n > 0
//       })
//         .populate('size_id')
//         .populate('color_id');

//       // N·∫øu kh√¥ng c√≥ variants h·ª£p l·ªá, b·ªè qua s·∫£n ph·∫©m n√†y
//       if (variants.length === 0) return null;

//       // T√≠nh gi√° min/max t·ª´ c√°c variants c√≥ s·∫µn
//       const prices = variants.map(v => v.price);
//       const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
//       const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;

//       return {
//         id: shoe._id,
//         name: shoe.name,
//         description: shoe.description,
//         brand: shoe.brand_id?.name,
//         category: shoe.category_id?.name,
//         image: shoe.media?.[0]?.url || '',
//         priceRange: `${minPrice.toLocaleString('vi-VN')} - ${maxPrice.toLocaleString('vi-VN')} VND`,
//         variants: variants.map(v => ({
//           color: v.color_id?.name,
//           size: v.size_id?.size_value,
//           price: v.price.toLocaleString('vi-VN') + ' VND',
//           stock: v.quantity_in_stock
//         }))
//       };
//     }));

//     // L·ªçc b·ªè c√°c s·∫£n ph·∫©m null (kh√¥ng c√≥ variants h·ª£p l·ªá)
//     const validProducts = shoesWithVariants.filter(product => product !== null);

//     // 2. T·∫°o prompt chi ti·∫øt cho AI
//     const productInfo = validProducts.map(shoe => `
//       S·∫£n ph·∫©m: ${shoe.name}
//       Th∆∞∆°ng hi·ªáu: ${shoe.brand}
//       Danh m·ª•c: ${shoe.category}
//       M√¥ t·∫£: ${shoe.description}
//       Gi√°: ${shoe.priceRange}
//       Bi·∫øn th·ªÉ c√≥ s·∫µn: ${shoe.variants.map(v => 
//         `${v.color} - Size ${v.size} (${v.price}, c√≤n ${v.stock} s·∫£n ph·∫©m)`
//       ).join(', ')}
//     `).join('\n\n');

//     const prompt = `
//     B·∫°n l√† m·ªôt tr·ª£ l√Ω b√°n h√†ng chuy√™n nghi·ªáp t·∫°i c·ª≠a h√†ng gi√†y. D∆∞·ªõi ƒë√¢y l√† danh s√°ch s·∫£n ph·∫©m c√≤n h√†ng c·ªßa ch√∫ng t√¥i:

//     ${productInfo}

//     Kh√°ch h√†ng h·ªèi: "${message}"

//     H√£y g·ª£i √Ω 3 s·∫£n ph·∫©m ph√π h·ª£p nh·∫•t v√† gi·∫£i th√≠ch l√Ω do ch·ªçn ch√∫ng. 
//     Tr·∫£ l·ªùi m·ªôt c√°ch chuy√™n nghi·ªáp, ng·∫Øn g·ªçn v√† thuy·∫øt ph·ª•c.
//     Nh·∫•n m·∫°nh v√†o c√°c ∆∞u ƒëi·ªÉm ph√π h·ª£p v·ªõi nhu c·∫ßu c·ªßa kh√°ch h√†ng.
//     ƒê·ªÅ c·∫≠p ƒë·∫øn gi√° c·∫£, th∆∞∆°ng hi·ªáu v√† c√°c bi·∫øn th·ªÉ c√≤n h√†ng.
//     N·∫øu kh√¥ng c√≥ s·∫£n ph·∫©m ph√π h·ª£p, h√£y th√¥ng b√°o cho kh√°ch h√†ng m·ªôt c√°ch l·ªãch s·ª±.
//     `;

//     // 3. G·ªçi API ChatGPT
//     const completion = await openai.chat.completions.create({
//       model: "gpt-3.5-turbo",
//       messages: [
//         { 
//           role: "system", 
//           content: "B·∫°n l√† m·ªôt tr·ª£ l√Ω b√°n h√†ng chuy√™n nghi·ªáp, gi√†u kinh nghi·ªám v·ªÅ gi√†y d√©p. H√£y giao ti·∫øp m·ªôt c√°ch th√¢n thi·ªán, chuy√™n nghi·ªáp v√† ƒë∆∞a ra nh·ªØng g·ª£i √Ω ph√π h·ª£p nh·∫•t cho kh√°ch h√†ng."
//         },
//         { 
//           role: "user", 
//           content: prompt 
//         }
//       ],
//       temperature: 0.7,
//       max_tokens: 800
//     });

//     // 4. Tr·∫£ v·ªÅ k·∫øt qu·∫£
//     res.json({
//       success: true, 
//       suggestions: completion.choices[0].message.content
//     });

//   } catch (error) {
//     console.error("AI Suggestion Error:", error);
//     res.status(500).json({
//       success: false,
//       message: "L·ªói khi g·ª£i √Ω s·∫£n ph·∫©m",
//       error: error.message 
//     });
//   }
// };


const { GoogleGenerativeAI } = require('@google/generative-ai');
const Shoes = require('../models/shoes.model');
const ShoesVariant = require('../models/shoes_variant.model');
require('dotenv').config();
const ChatLog = require('../models/chat_log.model');

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

exports.suggestProducts = async (req, res) => {
    try {
        const { message, user_id } = req.body;

        // 1. L·∫•y to√†n b·ªô s·∫£n ph·∫©m v√† bi·∫øn th·ªÉ h·ª£p l·ªá
        const shoes = await Shoes.find({ status: { $ne: 'hidden' } })
            .populate('brand_id')
            .populate('category_id');

        const shoesWithVariants = await Promise.all(
            shoes.map(async (shoe) => {
                const variants = await ShoesVariant.find({
                    shoes_id: shoe._id,
                    status: 'available',
                    quantity_in_stock: { $gt: 0 },
                },)
                    .populate('size_id')
                    .populate('color_id');

                if (variants.length === 0) return null;

                const prices = variants.map((v) => v.price);
                const minPrice = prices.length > 0 ? Math.min(...prices) : 0;
                const maxPrice = prices.length > 0 ? Math.max(...prices) : 0;

                return {
                    id: shoe._id,
                    name: shoe.name,
                    description: shoe.description,
                    brand: shoe.brand_id?.name,
                    category: shoe.category_id?.name,
                    image: shoe.media?.[0]?.url || '',
                    priceRange: `${minPrice.toLocaleString('vi-VN')} - ${maxPrice.toLocaleString('vi-VN')} ƒë`,
                    variants: variants.map((v) => ({
                        color: v.color_id?.name,
                        size: v.size_id?.size_value,
                        price: v.price.toLocaleString('vi-VN') + ' ƒë',
                        stock: v.quantity_in_stock,
                    })),
                };
            })
        );

        const validProducts = shoesWithVariants.filter((p) => p !== null);

        // 2. T·∫°o prompt cho Gemini c√≥ y√™u c·∫ßu TR·∫¢ V·ªÄ DANH S√ÅCH ID ho·∫∑c t√™n s·∫£n ph·∫©m
        const productInfo = validProducts
            .map((shoe, index) => `
                #${index + 1}:
                ID: ${shoe.id}
                T√™n: ${shoe.name}
                Th∆∞∆°ng hi·ªáu: ${shoe.brand}
                Danh m·ª•c: ${shoe.category}
                M√¥ t·∫£: ${shoe.description}
                Gi√°: ${shoe.priceRange}
                Bi·∫øn th·ªÉ: ${shoe.variants.map(v => `${v.color} - Size ${v.size} (${v.price})`).join(', ')}
                `)
            .join('\n\n');

        const prompt = `
            B·∫°n l√† m·ªôt tr·ª£ l√Ω b√°n h√†ng chuy√™n nghi·ªáp t·∫°i c·ª≠a h√†ng gi√†y. D∆∞·ªõi ƒë√¢y l√† danh s√°ch s·∫£n ph·∫©m c√≤n h√†ng:

            ${productInfo}

            Kh√°ch h√†ng h·ªèi: "${message}"

            üëâ H√£y tr·∫£ l·ªùi nh∆∞ sau:
            1. Vi·∫øt ph·∫ßn m·ªü ƒë·∫ßu g·ª£i √Ω 3 s·∫£n ph·∫©m ph√π h·ª£p v√† l√Ω do.
                - Ch·ªâ s·ª≠ d·ª•ng T√™n, Th∆∞∆°ng hi·ªáu, Danh m·ª•c, M√¥ t·∫£, Gi√°, Bi·∫øn th·ªÉ (vi·∫øt ng·∫Øn g·ªçn kh√¥ng c·∫ßn chi ti·∫øt qu√°, ph·∫ßn li·ªát k√™ c√≥ th·ªÉ s·ª≠ d·ª•ng -).
                - KH√îNG ƒë∆∞·ª£c vi·∫øt ID trong ph·∫ßn tr·∫£ l·ªùi n√†y.
                - Kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng k√Ω t·ª± Markdown (v√≠ d·ª•: **, __, #, *).
                - Tr·∫£ l·ªùi ch·ªâ b·∫±ng vƒÉn b·∫£n thu·∫ßn t√∫y.
            2. Cu·ªëi c√πng, tr·∫£ v·ªÅ danh s√°ch 3 ID s·∫£n ph·∫©m ƒë∆∞·ª£c ch·ªçn, (ph·∫£i tr·∫£ v·ªÅ √≠t nh·∫•t 1 ID)
            d∆∞·ªõi d·∫°ng JSON nh∆∞ sau:
            {"selected_product_ids": ["id1", "id2", "id3"]}
            `;

        // 3. G·ªçi Gemini
        const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });
        const result = await model.generateContent(prompt);
        const response = await result.response;
        const fullText = response.text();
        console.log('Gemini Response:', JSON.stringify(fullText, null, 2));

        // 4. Parse JSON cu·ªëi trong text (ID c·ªßa 3 s·∫£n ph·∫©m ƒë∆∞·ª£c ch·ªçn)
        const match = fullText.match(/\{[\s\S]*"selected_product_ids"[\s\S]*?\}/);
        let selectedIds = [];

        if (match) {
            const jsonPart = JSON.parse(match[0]);
            selectedIds = jsonPart.selected_product_ids || [];
        }

        // 5. L·∫•y l·∫°i th√¥ng tin chi ti·∫øt 3 s·∫£n ph·∫©m ƒë∆∞·ª£c ch·ªçn
        const selectedProducts = validProducts.filter((p) =>
            selectedIds.includes(p.id.toString())
        );

        // L∆∞u chat log
        const chatLog = new ChatLog({
            user_id,
            message,
            ai_response: fullText,
            selected_products: selectedProducts.map(p => ({
                product_id: p.id,
                name: p.name,
                image: p.image,
                price_range: p.priceRange
            }))
        });
        await chatLog.save();

        // 6. Tr·∫£ v·ªÅ
        res.json({
            status: 200,
            message: 'G·ª£i √Ω s·∫£n ph·∫©m th√†nh c√¥ng',
            data: {
                chat_id: chatLog._id,
                suggestions: fullText,
                products: selectedProducts
            }

        });
    }
    catch (error) {
        console.error('AI Suggestion Error:', error);

        if (error.response?.status === 429) {
            // H·∫øt quota
            return res.status(429).json({
                status: 429,
                message: "B·∫°n ƒë√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n g·ªçi API AI h√¥m nay. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c n√¢ng c·∫•p g√≥i!"
            });
        }

        // N·∫øu model AI qu√° t·∫£i (503)
        if (error.status === 503 || error.message?.includes('503')) {
            return res.status(503).json({
                status: 503,
                message: 'D·ªãch v·ª• AI ƒëang qu√° t·∫£i. Vui l√≤ng th·ª≠ l·∫°i sau.',
            });
        }

        res.status(500).json({
            status: 500,
            message: 'AI error',
            error: error.message
        });
    }

};

// L·∫•y l·ªãch s·ª≠ chat c·ªßa user
exports.getChatHistory = async (req, res) => {
    try {
        const { user_id } = req.params;
        const { page = 1, limit = 10 } = req.query;

        const chats = await ChatLog.find({
            user_id,
            is_deleted: false
        })
            .sort({ created_at: -1 })
            .skip((page - 1) * limit)
            .limit(limit)
            .populate({
                path: 'selected_products.product_id',   // populate product_id
                populate: {
                    path: 'brand_id',                   // populate brand_id trong product
                    select: 'name',                // ch·ªçn field c·∫ßn thi·∫øt (n·∫øu mu·ªën)
                }
            });

        const total = await ChatLog.countDocuments({
            user_id,
            is_deleted: false
        });

        res.json({
            success: true,
            data: {
                chats,
                pagination: {
                    total,
                    page: parseInt(page),
                    total_pages: Math.ceil(total / limit)
                }
            }
        });

    } catch (error) {
        console.error('Error getting chat history:', error);
        res.status(500).json({
            success: false,
            message: 'Error getting chat history',
            error: error.message
        });
    }
};

// X√≥a m·ªôt chat
exports.deleteChat = async (req, res) => {
    try {
        const { chat_id } = req.params;

        const chat = await ChatLog.findById(chat_id);
        if (!chat) {
            return res.status(404).json({
                success: false,
                message: 'Chat not found'
            });
        }

        chat.is_deleted = true;
        await chat.save();

        res.json({
            success: true,
            message: 'Chat deleted successfully'
        });

    } catch (error) {
        console.error('Error deleting chat:', error);
        res.status(500).json({
            success: false,
            message: 'Error deleting chat',
            error: error.message
        });
    }
};

// X√≥a t·∫•t c·∫£ chat c·ªßa user
exports.deleteAllChats = async (req, res) => {
    try {
        const { user_id } = req.params;

        await ChatLog.updateMany(
            { user_id },
            { $set: { is_deleted: true } }
        );

        res.json({
            success: true,
            message: 'All chats deleted successfully'
        });

    } catch (error) {
        console.error('Error deleting all chats:', error);
        res.status(500).json({
            success: false,
            message: 'Error deleting all chats',
            error: error.message
        });
    }
};
